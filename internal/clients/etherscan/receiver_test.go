// Copyright 2022 Mailchain Ltd.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package etherscan

import (
	"context"
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/mailchain/mailchain/crypto/cipher"
	"github.com/mailchain/mailchain/stores"
	"github.com/stretchr/testify/assert"
)

func TestReceive(t *testing.T) {
	type args struct {
		ctx      context.Context
		protocol string
		network  string
	}
	tests := []struct {
		name    string
		args    args
		wantErr error
		wantNil bool
		want    []stores.Transaction
	}{
		{
			"err-network-not-supported",
			args{
				context.Background(),
				"ethereum",
				"InvalidNetwork",
			},
			errors.New("network not supported"),
			true,
			nil,
		},
		{
			"err-unmarshal",
			args{
				context.Background(),
				"ethereum",
				"TestNetwork",
			},
			errors.New("{invalid}: invalid character 'i' looking for beginning of object key string"),
			true,
			nil,
		},
		{
			"err-get",
			args{
				context.Background(),
				"ethereum",
				"TestNetwork",
			},
			nil,
			false,
			[]stores.Transaction{},
		},
		{
			"success-remove-invalid-tx",
			args{
				context.Background(),
				"ethereum",
				"TestNetwork",
			},
			nil,
			false,
			[]stores.Transaction{
				{
					EnvelopeData: cipher.EncryptedContent{0x38, 0x31, 0x62, 0x33, 0x66, 0x36, 0x38, 0x35, 0x39, 0x32, 0x64, 0x31, 0x39, 0x33, 0x38, 0x39, 0x64, 0x39, 0x65, 0x64, 0x32, 0x34, 0x66, 0x64, 0x63, 0x63, 0x38, 0x31, 0x63, 0x31, 0x66, 0x66, 0x30, 0x32, 0x38, 0x35, 0x38, 0x39, 0x62, 0x65, 0x35, 0x35, 0x30, 0x34, 0x36, 0x30, 0x35, 0x32, 0x36, 0x66, 0x31, 0x63, 0x39, 0x61, 0x61, 0x34, 0x36, 0x62, 0x38, 0x64, 0x33, 0x37, 0x39, 0x34, 0x63, 0x37, 0x65, 0x30, 0x32, 0x61, 0x65, 0x65, 0x36, 0x35, 0x63, 0x38, 0x66, 0x31, 0x37, 0x37, 0x33, 0x37, 0x63, 0x61, 0x36, 0x66, 0x37, 0x33, 0x35, 0x64, 0x39, 0x35, 0x65, 0x30, 0x39, 0x65, 0x36, 0x61, 0x31, 0x39, 0x66, 0x36, 0x30, 0x38, 0x38, 0x36, 0x66, 0x38, 0x31, 0x32, 0x39, 0x32, 0x65, 0x35, 0x37, 0x38, 0x35, 0x37, 0x31, 0x33, 0x34, 0x35, 0x62, 0x38, 0x65, 0x31, 0x65, 0x34, 0x66, 0x39, 0x32, 0x38, 0x32, 0x65, 0x31, 0x30, 0x64, 0x33, 0x39, 0x66, 0x37, 0x31, 0x62, 0x38, 0x63, 0x66, 0x39, 0x65, 0x37, 0x31, 0x61, 0x32, 0x31, 0x65, 0x63, 0x36, 0x39, 0x39, 0x39, 0x33, 0x36, 0x37, 0x34, 0x66, 0x34, 0x61, 0x62, 0x61, 0x64, 0x32, 0x31, 0x62, 0x38, 0x31, 0x39, 0x35, 0x31, 0x64, 0x65, 0x65, 0x34, 0x66, 0x65, 0x64, 0x35, 0x65, 0x66, 0x64, 0x65, 0x66, 0x33, 0x34, 0x64, 0x31, 0x31, 0x30, 0x32, 0x64, 0x34, 0x63, 0x33, 0x33, 0x65, 0x38, 0x62, 0x66, 0x62, 0x61, 0x33, 0x30, 0x62, 0x34, 0x61, 0x34, 0x37, 0x30, 0x64, 0x61, 0x62, 0x64, 0x34, 0x34, 0x65, 0x39, 0x38, 0x65, 0x32, 0x62, 0x36, 0x34, 0x39, 0x34, 0x61, 0x36, 0x65, 0x38, 0x62, 0x36, 0x39, 0x63, 0x39, 0x33, 0x36, 0x35, 0x38, 0x64, 0x39, 0x36, 0x31, 0x39, 0x36, 0x39, 0x35, 0x66, 0x33, 0x31, 0x35, 0x61, 0x35, 0x62, 0x66, 0x35, 0x62, 0x62, 0x31, 0x38, 0x65, 0x36, 0x32, 0x65, 0x33, 0x62, 0x66, 0x62, 0x32, 0x37, 0x36, 0x34, 0x63, 0x36, 0x33, 0x35, 0x32, 0x36, 0x31, 0x61, 0x63, 0x66, 0x36, 0x37, 0x30, 0x30, 0x38, 0x62, 0x35, 0x37, 0x61, 0x31, 0x62, 0x62, 0x33, 0x38, 0x38, 0x35, 0x31, 0x64, 0x39, 0x61, 0x32, 0x65, 0x66, 0x35, 0x35, 0x37, 0x30, 0x32, 0x38, 0x61, 0x33, 0x61, 0x66, 0x37, 0x38, 0x39, 0x64, 0x65, 0x37, 0x39, 0x62, 0x34, 0x34, 0x66, 0x62, 0x34, 0x61, 0x30, 0x33, 0x61, 0x37, 0x65, 0x36, 0x37, 0x39, 0x30, 0x37, 0x34, 0x30, 0x30, 0x37, 0x65, 0x31, 0x62, 0x32, 0x37},
					BlockNumber:  65204,
					Hash:         []uint8{0x30, 0x78, 0x39, 0x38, 0x62, 0x65, 0x62, 0x32, 0x37, 0x31, 0x33, 0x35, 0x61, 0x61, 0x30, 0x61, 0x32, 0x35, 0x36, 0x35, 0x30, 0x35, 0x35, 0x37, 0x30, 0x30, 0x35, 0x61, 0x64, 0x39, 0x36, 0x32, 0x39, 0x31, 0x39, 0x64, 0x36, 0x61, 0x32, 0x37, 0x38, 0x63, 0x34, 0x62, 0x33, 0x64, 0x64, 0x65, 0x37, 0x66, 0x34, 0x66, 0x36, 0x61, 0x33, 0x61, 0x31, 0x65, 0x36, 0x35, 0x61, 0x61, 0x37, 0x34, 0x36, 0x63},
				},
			},
		},
		{
			"success-remove-empty-input-tx",
			args{
				context.Background(),
				"ethereum",
				"TestNetwork",
			},
			nil,
			false,
			[]stores.Transaction{
				{
					EnvelopeData: cipher.EncryptedContent{0x38, 0x31, 0x62, 0x33, 0x66, 0x36, 0x38, 0x35, 0x39, 0x32, 0x64, 0x31, 0x39, 0x33, 0x38, 0x39, 0x64, 0x39, 0x65, 0x64, 0x32, 0x34, 0x66, 0x64, 0x63, 0x63, 0x38, 0x31, 0x63, 0x31, 0x66, 0x66, 0x30, 0x32, 0x38, 0x35, 0x38, 0x39, 0x62, 0x65, 0x35, 0x35, 0x30, 0x34, 0x36, 0x30, 0x35, 0x32, 0x36, 0x66, 0x31, 0x63, 0x39, 0x61, 0x61, 0x34, 0x36, 0x62, 0x38, 0x64, 0x33, 0x37, 0x39, 0x34, 0x63, 0x37, 0x65, 0x30, 0x32, 0x61, 0x65, 0x65, 0x36, 0x35, 0x63, 0x38, 0x66, 0x31, 0x37, 0x37, 0x33, 0x37, 0x63, 0x61, 0x36, 0x66, 0x37, 0x33, 0x35, 0x64, 0x39, 0x35, 0x65, 0x30, 0x39, 0x65, 0x36, 0x61, 0x31, 0x39, 0x66, 0x36, 0x30, 0x38, 0x38, 0x36, 0x66, 0x38, 0x31, 0x32, 0x39, 0x32, 0x65, 0x35, 0x37, 0x38, 0x35, 0x37, 0x31, 0x33, 0x34, 0x35, 0x62, 0x38, 0x65, 0x31, 0x65, 0x34, 0x66, 0x39, 0x32, 0x38, 0x32, 0x65, 0x31, 0x30, 0x64, 0x33, 0x39, 0x66, 0x37, 0x31, 0x62, 0x38, 0x63, 0x66, 0x39, 0x65, 0x37, 0x31, 0x61, 0x32, 0x31, 0x65, 0x63, 0x36, 0x39, 0x39, 0x39, 0x33, 0x36, 0x37, 0x34, 0x66, 0x34, 0x61, 0x62, 0x61, 0x64, 0x32, 0x31, 0x62, 0x38, 0x31, 0x39, 0x35, 0x31, 0x64, 0x65, 0x65, 0x34, 0x66, 0x65, 0x64, 0x35, 0x65, 0x66, 0x64, 0x65, 0x66, 0x33, 0x34, 0x64, 0x31, 0x31, 0x30, 0x32, 0x64, 0x34, 0x63, 0x33, 0x33, 0x65, 0x38, 0x62, 0x66, 0x62, 0x61, 0x33, 0x30, 0x62, 0x34, 0x61, 0x34, 0x37, 0x30, 0x64, 0x61, 0x62, 0x64, 0x34, 0x34, 0x65, 0x39, 0x38, 0x65, 0x32, 0x62, 0x36, 0x34, 0x39, 0x34, 0x61, 0x36, 0x65, 0x38, 0x62, 0x36, 0x39, 0x63, 0x39, 0x33, 0x36, 0x35, 0x38, 0x64, 0x39, 0x36, 0x31, 0x39, 0x36, 0x39, 0x35, 0x66, 0x33, 0x31, 0x35, 0x61, 0x35, 0x62, 0x66, 0x35, 0x62, 0x62, 0x31, 0x38, 0x65, 0x36, 0x32, 0x65, 0x33, 0x62, 0x66, 0x62, 0x32, 0x37, 0x36, 0x34, 0x63, 0x36, 0x33, 0x35, 0x32, 0x36, 0x31, 0x61, 0x63, 0x66, 0x36, 0x37, 0x30, 0x30, 0x38, 0x62, 0x35, 0x37, 0x61, 0x31, 0x62, 0x62, 0x33, 0x38, 0x38, 0x35, 0x31, 0x64, 0x39, 0x61, 0x32, 0x65, 0x66, 0x35, 0x35, 0x37, 0x30, 0x32, 0x38, 0x61, 0x33, 0x61, 0x66, 0x37, 0x38, 0x39, 0x64, 0x65, 0x37, 0x39, 0x62, 0x34, 0x34, 0x66, 0x62, 0x34, 0x61, 0x30, 0x33, 0x61, 0x37, 0x65, 0x36, 0x37, 0x39, 0x30, 0x37, 0x34, 0x30, 0x30, 0x37, 0x65, 0x31, 0x62, 0x32, 0x37},
					BlockNumber:  65204,
					Hash:         []uint8{0x30, 0x78, 0x39, 0x38, 0x62, 0x65, 0x62, 0x32, 0x37, 0x31, 0x33, 0x35, 0x61, 0x61, 0x30, 0x61, 0x32, 0x35, 0x36, 0x35, 0x30, 0x35, 0x35, 0x37, 0x30, 0x30, 0x35, 0x61, 0x64, 0x39, 0x36, 0x32, 0x39, 0x31, 0x39, 0x64, 0x36, 0x61, 0x32, 0x37, 0x38, 0x63, 0x34, 0x62, 0x33, 0x64, 0x64, 0x65, 0x37, 0x66, 0x34, 0x66, 0x36, 0x61, 0x33, 0x61, 0x31, 0x65, 0x36, 0x35, 0x61, 0x61, 0x37, 0x34, 0x36, 0x63},
				},
			},
		},
		{
			"success-removes-duplicated-tx",
			args{
				context.Background(),
				"ethereum",
				"TestNetwork",
			},
			nil,
			false,
			[]stores.Transaction{
				{
					EnvelopeData: cipher.EncryptedContent{0x38, 0x31, 0x62, 0x33, 0x66, 0x36, 0x38, 0x35, 0x39, 0x32, 0x64, 0x31, 0x39, 0x33, 0x38, 0x39, 0x64, 0x39, 0x65, 0x64, 0x32, 0x34, 0x66, 0x64, 0x63, 0x63, 0x38, 0x31, 0x63, 0x31, 0x66, 0x66, 0x30, 0x32, 0x38, 0x35, 0x38, 0x39, 0x62, 0x65, 0x35, 0x35, 0x30, 0x34, 0x36, 0x30, 0x35, 0x32, 0x36, 0x66, 0x31, 0x63, 0x39, 0x61, 0x61, 0x34, 0x36, 0x62, 0x38, 0x64, 0x33, 0x37, 0x39, 0x34, 0x63, 0x37, 0x65, 0x30, 0x32, 0x61, 0x65, 0x65, 0x36, 0x35, 0x63, 0x38, 0x66, 0x31, 0x37, 0x37, 0x33, 0x37, 0x63, 0x61, 0x36, 0x66, 0x37, 0x33, 0x35, 0x64, 0x39, 0x35, 0x65, 0x30, 0x39, 0x65, 0x36, 0x61, 0x31, 0x39, 0x66, 0x36, 0x30, 0x38, 0x38, 0x36, 0x66, 0x38, 0x31, 0x32, 0x39, 0x32, 0x65, 0x35, 0x37, 0x38, 0x35, 0x37, 0x31, 0x33, 0x34, 0x35, 0x62, 0x38, 0x65, 0x31, 0x65, 0x34, 0x66, 0x39, 0x32, 0x38, 0x32, 0x65, 0x31, 0x30, 0x64, 0x33, 0x39, 0x66, 0x37, 0x31, 0x62, 0x38, 0x63, 0x66, 0x39, 0x65, 0x37, 0x31, 0x61, 0x32, 0x31, 0x65, 0x63, 0x36, 0x39, 0x39, 0x39, 0x33, 0x36, 0x37, 0x34, 0x66, 0x34, 0x61, 0x62, 0x61, 0x64, 0x32, 0x31, 0x62, 0x38, 0x31, 0x39, 0x35, 0x31, 0x64, 0x65, 0x65, 0x34, 0x66, 0x65, 0x64, 0x35, 0x65, 0x66, 0x64, 0x65, 0x66, 0x33, 0x34, 0x64, 0x31, 0x31, 0x30, 0x32, 0x64, 0x34, 0x63, 0x33, 0x33, 0x65, 0x38, 0x62, 0x66, 0x62, 0x61, 0x33, 0x30, 0x62, 0x34, 0x61, 0x34, 0x37, 0x30, 0x64, 0x61, 0x62, 0x64, 0x34, 0x34, 0x65, 0x39, 0x38, 0x65, 0x32, 0x62, 0x36, 0x34, 0x39, 0x34, 0x61, 0x36, 0x65, 0x38, 0x62, 0x36, 0x39, 0x63, 0x39, 0x33, 0x36, 0x35, 0x38, 0x64, 0x39, 0x36, 0x31, 0x39, 0x36, 0x39, 0x35, 0x66, 0x33, 0x31, 0x35, 0x61, 0x35, 0x62, 0x66, 0x35, 0x62, 0x62, 0x31, 0x38, 0x65, 0x36, 0x32, 0x65, 0x33, 0x62, 0x66, 0x62, 0x32, 0x37, 0x36, 0x34, 0x63, 0x36, 0x33, 0x35, 0x32, 0x36, 0x31, 0x61, 0x63, 0x66, 0x36, 0x37, 0x30, 0x30, 0x38, 0x62, 0x35, 0x37, 0x61, 0x31, 0x62, 0x62, 0x33, 0x38, 0x38, 0x35, 0x31, 0x64, 0x39, 0x61, 0x32, 0x65, 0x66, 0x35, 0x35, 0x37, 0x30, 0x32, 0x38, 0x61, 0x33, 0x61, 0x66, 0x37, 0x38, 0x39, 0x64, 0x65, 0x37, 0x39, 0x62, 0x34, 0x34, 0x66, 0x62, 0x34, 0x61, 0x30, 0x33, 0x61, 0x37, 0x65, 0x36, 0x37, 0x39, 0x30, 0x37, 0x34, 0x30, 0x30, 0x37, 0x65, 0x31, 0x62, 0x32, 0x37},
					BlockNumber:  65204,
					Hash:         []uint8{0x30, 0x78, 0x39, 0x38, 0x62, 0x65, 0x62, 0x32, 0x37, 0x31, 0x33, 0x35, 0x61, 0x61, 0x30, 0x61, 0x32, 0x35, 0x36, 0x35, 0x30, 0x35, 0x35, 0x37, 0x30, 0x30, 0x35, 0x61, 0x64, 0x39, 0x36, 0x32, 0x39, 0x31, 0x39, 0x64, 0x36, 0x61, 0x32, 0x37, 0x38, 0x63, 0x34, 0x62, 0x33, 0x64, 0x64, 0x65, 0x37, 0x66, 0x34, 0x66, 0x36, 0x61, 0x33, 0x61, 0x31, 0x65, 0x36, 0x35, 0x61, 0x61, 0x37, 0x34, 0x36, 0x63},
				},
			},
		},
	}
	for _, tt := range tests {
		testName := t.Name()
		t.Run(tt.name, func(t *testing.T) {
			golden, err := ioutil.ReadFile(fmt.Sprintf("./testdata/%s/%s.json", testName, tt.name))
			if err != nil {
				assert.FailNow(t, err.Error())
			}
			server := httptest.NewServer(
				http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
					w.Write([]byte(golden))
				}),
			)
			defer server.Close()
			client := &APIClient{
				key:            "api-key",
				networkConfigs: map[string]networkConfig{"TestNetwork": {url: server.URL}},
			}
			got, err := client.Receive(tt.args.ctx, tt.args.protocol, tt.args.network, []byte{})
			if (err != nil) && !assert.Equal(t, tt.wantErr.Error(), err.Error()) {
				t.Errorf("APIClient.Receive() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if (got == nil) != tt.wantNil {
				t.Errorf("APIClient.Receive() nil = %v, wantNil %v", got == nil, tt.wantNil)
				return
			}
			if !assert.Equal(t, tt.want, got) {
				t.Errorf("APIClient.Receive() = %v, want %v", got, tt.want)
			}
		})
	}
}
